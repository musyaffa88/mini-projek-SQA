"use strict";
// tslint:disable-next-line
/// <reference path="global.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.chaiImage = exports.Align = void 0;
const crypto = require("crypto");
const fs = require("fs");
const mkdirp = require("mkdirp");
const path = require("path");
const pixelmatch = require("pixelmatch"); // tslint:disable-line
const pngjs_1 = require("pngjs");
var Align;
(function (Align) {
    Align["LEFT_TOP"] = "leftTop";
    Align["CENTER"] = "center";
})(Align = exports.Align || (exports.Align = {}));
exports.chaiImage = (chai, utils) => {
    const { Assertion } = chai;
    Assertion.addMethod("matchImage", function matchImage(expected, options = {}) {
        const actual = this._obj;
        // Check Type of parameters
        // In this case, we don't use this.assert since we don't need to support negate
        chai.assert(Buffer.isBuffer(actual), `actual image must be a Buffer, but ${utils.objDisplay(actual)} given`);
        chai.assert(Buffer.isBuffer(expected), `expected image must be a Buffer, but ${utils.objDisplay(expected)} given`);
        const [imgExpected, imgActual] = (() => {
            try {
                return loadImages(actual, expected, options.align);
            }
            catch (e) {
                if (/invalid/i.test(e.message)) {
                    throw new chai.AssertionError("image must be a valid PNG image");
                }
                throw e;
            }
        })();
        // Try hash comparision
        const actualHash = crypto.createHash("sha1").update(imgActual.data).digest();
        const expectedHash = crypto.createHash("sha1").update(imgExpected.data).digest();
        if (actualHash !== expectedHash) {
            // if hash is different, perform imagediff
            const { width, height } = imgExpected;
            const imgDiff = new pngjs_1.PNG({ width, height });
            const diffPixelCount = pixelmatch(imgActual.data, imgExpected.data, imgDiff.data, width, height, options.diff);
            const passed = diffPixelCount === 0;
            if (options.output) {
                saveImages(passed, imgActual, imgExpected, imgDiff, options.output);
            }
            this.assert(passed, `expected image to match given image, but ${diffPixelCount} pixels different`, `expected image not to match given image, but none was different`, passed);
        }
    });
};
// Load images, and perform pre-processing if needed
function loadImages(bufActual, bufExpected, align = Align.LEFT_TOP) {
    // Load image pixels first
    const rawExpected = pngjs_1.PNG.sync.read(bufExpected);
    const rawActual = pngjs_1.PNG.sync.read(bufActual);
    // Check dimensions to decide preprocessing, or not
    const hasEqualDimensions = rawActual.width === rawExpected.width
        && rawActual.height === rawExpected.height;
    // If given two images have same dimensions, skip preprocessing.
    if (hasEqualDimensions) {
        return [rawExpected, rawActual];
    }
    const width = Math.max(rawActual.width, rawExpected.width);
    const height = Math.max(rawActual.height, rawExpected.height);
    return [rawExpected, rawActual].map((source) => {
        // Create a new empty PNG image to generate resized image output
        const resized = new pngjs_1.PNG({ width, height, fill: true });
        // Compute image position to align
        const [deltaX, deltaY] = align === Align.CENTER ? [
            Math.floor((width - source.width) / 2),
            Math.floor((height - source.height) / 2),
        ] : [0, 0];
        // Copy source pixel data into created PNG image
        pngjs_1.PNG.bitblt(source, resized, 0, 0, source.width, source.height, deltaX, deltaY);
        // Fill non-source area (background)
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const isBackgroundPixel = x > source.width || y > source.height;
                if (isBackgroundPixel) {
                    const offset = ((width * y) + x) << 2; // tslint:disable-line
                    resized.data[offset] = 0x00; // R
                    resized.data[offset + 1] = 0x00; // G
                    resized.data[offset + 2] = 0x00; // B
                    resized.data[offset + 3] = 0x40; // A
                }
            }
        }
        return resized;
    });
}
function saveImages(passed, imgActual, imgExpected, imgDiff, options) {
    const { name = crypto.randomBytes(4).toString("hex"), dir = "output", on = "failure", diffOnly = false, } = options;
    const satisfiedCreation = on === "always" || (on === "failure" && !passed);
    if (satisfiedCreation) {
        mkdirp.sync(dir);
        if (!diffOnly) {
            fs.writeFileSync(path.join(dir, `${name}_actual.png`), pngjs_1.PNG.sync.write(imgActual, { filterType: 4 }));
            fs.writeFileSync(path.join(dir, `${name}_expected.png`), pngjs_1.PNG.sync.write(imgExpected, { filterType: 4 }));
        }
        fs.writeFileSync(path.join(dir, `${name}_diff.png`), pngjs_1.PNG.sync.write(imgDiff, { filterType: 4 }));
    }
}
//# sourceMappingURL=index.js.map